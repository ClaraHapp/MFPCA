% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/univariateExpansions.R
\name{univBasisExpansion}
\alias{univBasisExpansion}
\title{Calculate a univariate spline basis expansion for a functional data object}
\usage{
univBasisExpansion(funDataObject, bs = NULL, m = rep(2,
  dimSupp(funDataObject)), k = rep(-1, dimSupp(funDataObject)), pen = FALSE)
}
\arguments{
\item{funDataObject}{An object of class \code{\link[funData]{funData}}
containing the observed functional data, for which the bases representation
is calculated.}

\item{bs}{A character string, the type of basis functions to be used. Defaults to p-Splines
(\code{"ps"}) for functions on one-dimensional domain and to thin plate
regression splines (\code{"tp"}) in case of two-dimensional support. Please
refer to \code{\link[mgcv]{smooth.terms}} for a list of possible basis
functions.}

\item{m}{An array (or a single character), the order of the spline basis.
Defaults to \code{2}, as in \code{\link[mgcv]{gam}} /
\code{\link[mgcv]{bam}}. See \code{\link[mgcv]{s}} for details.}

\item{k}{An array (or a single character), the number of basis functions
used.  Defaults to \code{-1}, as in \code{\link[mgcv]{gam}} /
\code{\link[mgcv]{bam}}. See \code{\link[mgcv]{s}} for details.}

\item{pen}{Logical. If \code{TRUE}, the basis expansion is fit using an
  appropriate penalization term. Defaults to \code{FALSE}.}
}
\value{
\item{scores}{A matrix of weights with dimension \code{N x k},
reflecting the weights for each basis function in each observation.}
\item{functions}{A \code{\link[funData]{funData}} object representing the
basis functions.} \item{basisLong}{A matrix representing the basis functions
in vectorized form (only if \code{funDataobject} is defined on a
two-dimensional domain).}
}
\description{
This function calculates a univariate spline basis expansion for a functional
data object defined on a one- or two-dimensional domain. All basis functions
implemented for the functions \code{\link[mgcv]{gam}} /
\code{\link[mgcv]{bam}} in the \pkg{mgvc} package can be used. For functions
with two-dimensional domain, spline basis tensor products are used. If data
should be pre-smoothed, e.g. due to considerable measurement error, the
expansion is fit using an appropriate penalty term.
}
\examples{
oldPar <- par(no.readonly = TRUE)
set.seed(1)

# simulate some data (univariate)
sim <- simFunData(xVal = seq(-1,1, 0.01), M = 5, eFunType = "Poly",
                  eValType = "exponential", N = 7)$simData
noisy <- addError(sim, sd = 0.5) # a noisy version of sim

simBasis <- univBasisExpansion(sim, pen = FALSE)
noiseBasis <- univBasisExpansion(noisy, pen = TRUE)

# check reconstruction
par(mfrow = c(1,2))
plot(sim, main = "Simulated data")
plot(noisy, type = "p", pch = 20, cex = 0.3, add = TRUE)
legend("bottomright", c("sim", "noisy"), lty = c(1,NA), pch = c(NA, 20), pt.cex = 0.3)

plot(funData(simBasis$functions@xVal, simBasis$scores \%*\% simBasis$functions@X),
     main = "Reconstruction based on\\nbasis expansion")
plot(funData(noiseBasis$functions@xVal, noiseBasis$scores \%*\% noiseBasis$functions@X),
     lty = 3, add = TRUE)
legend("bottomright", c("sim, pen = FALSE", "noisy, pen = TRUE"), lty = c(1,3))

par(oldPar)
}
\seealso{
\code{\link[mgcv]{gam}}, \code{\link[mgcv]{s}},
  \code{\link[mgcv]{te}}, \code{\link{MFPCA}}, \code{\link{PACE}}.
}

